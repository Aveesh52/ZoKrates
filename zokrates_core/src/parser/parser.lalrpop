use absy::{Expression, Statement, Variable, ExpressionList, Parameter, Function, Prog};
use field::Field;
use types::{Type, Signature};
use imports::Import;

grammar<T> where T : Field;

// Define some helper macros (built-ins don't work, see lalrpop #417)

Cat<E1, E2> = <E1> E2;

Opt<E> : Option<E> = {
"" => None,
E => Some(<>)
}

Star<E> : Vec<E> = {
<v: Star<E>> <e: E> => {let mut v = v; v.push(e); v},
"" => vec![]
}

Plus<E> : Vec<E> = {
  <v: Star<E>> <e: E> => { let mut v = v; v.push(e); v},
  E => vec![<>]
}

SepList<E, S> : Vec<E> = <v:Star<Cat<E,S>>> <e:Opt<E>> => {
    match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

// Basic terminals

Ide : String = <s:r"[a-zA-Z][a-zA-Z0-9]*"> => s.to_string();
Num : T  = <n:r"[0-9]+"> => T::from(n);

// Expression grammar

Identifier : Expression<T> = <Ide> => Expression::Identifier::<T>(<>);
Number : Expression<T> = <Num> => Expression::Number(<>);

Factor = {
    Number,
    Identifier,
    "(" <Expr> ")",
    <a:Factor>"**"<b:Number> => Expression::Pow(box a, box b)
}

Term = {
    <a:Term>"*"<b:Factor> => Expression::Mult(box a, box b),
    <a:Term>"/"<b:Factor> => Expression::Div(box a, box b),
    Factor
}

Condition : Expression<T>= {
    <a:Expr>"=="<b:Expr> => Expression::Eq(box a, box b),
    <a:Expr>"<"<b:Expr> => Expression::Lt(box a, box b),
    <a:Expr>"<="<b:Expr> => Expression::Le(box a, box b),
    <a:Expr>">"<b:Expr> => Expression::Gt(box a, box b),
    <a:Expr>">="<b:Expr> => Expression::Ge(box a, box b),
    "(" <BoolExpr> ")"
}

BoolTerm : Expression<T> = {
    <c:Condition> "&&" <b:BoolTerm> => Expression::AndAnd(box c, box b),
    <Condition>
}

BoolExpr : Expression<T> = {
    <t:BoolTerm> "||" <e:BoolExpr> => Expression::Or(box t, box e),
    <BoolTerm>
}

IfElse: Expression<T>  = "if" <a:BoolExpr> "then" <b:Expr> "else" <c:Expr> "fi"
                       => Expression::IfElse(box a, box b, box c);

FunctionCall : Expression<T> = <f:Ide> "(" <args:SepList<Expr, ",">> ")"
                             => Expression::FunctionCall(f, args);

Expr : Expression<T> = {
    <a:Expr>"+"<b:Term> => Expression::Add(box a, box b),
    <a:Expr>"-"<b:Term> => Expression::Sub(box a, box b),
    FunctionCall,
    IfElse,
    Term
}

// Statement Grammar

Type : Type = {
     "field" => Type::FieldElement,
     "bool" => Type::Boolean
}

Definition : Vec<Statement<T>> = <x:Ide> "=" <e:Expr> => vec![Statement::Definition(x, e)];

Declaration : Vec<Statement<T>> = <t:Type> <x:Ide> "=" <e:Expr>
                                => vec![Statement::Declaration(Variable::new(x.clone(), t)),
                                        Statement::Definition(x, e)];

ForLoop : Vec<Statement<T>> = "for" <t:Type> <i:Ide> "in" <n1:Num> ".." <n2:Num> "do"
                                  <s:SepList<Statement, ";">>
                              "endfor"
                            => vec![Statement::For(Variable::new(i, t), n1, n2, s.into_iter().flatten().collect())];

Comment : Vec<Statement<T>> = r"//.*" => vec![];

Statement : Vec<Statement<T>> = {
   <Expr> "==" <Expr> => vec![Statement::Condition(<>)],
   Definition,
   Declaration,
   ForLoop,
   <Statement> Comment,
}

// Function grammar

ExpressionList : ExpressionList<T> = SepList<Expr, ","> => ExpressionList{expressions: <>};

Return : Vec<Statement<T>> = "return" <ExpressionList> => vec![Statement::Return(<>)];

FunctionArg : Parameter = <p:Opt<"private">> <t:Type> <x:Ide>
                        => Parameter{id : Variable::new(x, t), private: p.is_some()};

FunctionHeader : (String, Vec<Parameter>, Signature) = "def" <f:Ide> "(" <args:SepList<FunctionArg, ",">> ")"
                                                       "->" "(" <rets:SepList<Type, ",">> ")"
 => (f, args.clone(), Signature{inputs : args.into_iter().map(|a| a.id.get_type()).collect(), outputs: rets});

Function : Function<T> = <h:FunctionHeader> <s:SepList<Statement, ";">> <r:Return>
                           => {let (id, args, sig) = h;
                               let mut s = s;
                               s.push(r);
                               Function{id: id,
                                        arguments: args,
                                        statements: s.into_iter().flatten().collect(),
                                        signature: sig}
                               };

// Program grammar

As : String = "as" <Ide>;

Import : Import = "import" <p:r#""([\.\w/]*)""#> <i:Opt<As>>
                => match i {
                            None => Import::new(p.to_string()),
                            Some(alias) => Import::new_with_alias(p.to_string(), &alias)
                            };

pub Program : Prog<T> = <imports:Star<Import>> <functions:Star<Function>>
                      => Prog{functions, imports, imported_functions: vec![]};