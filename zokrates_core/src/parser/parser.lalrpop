use absy::{Expression, Statement, Variable, ExpressionList, Parameter, Function, Prog};
use field::Field;
use types::{Type, Signature};
use imports::Import;

grammar<T> where T : Field;

// SepList<E, S, final> is a list of <E> separated by <S>, with a final separator either
// present ("true"), absent ("false"), or optional ("opt")
SepList<E, S, TrailingSep> : Vec<E> = {
    "" => vec![],
    <(<E> S)*> if TrailingSep == "true",
    <v : (<E> S)*> <e : E> if TrailingSep == "false" => { let mut v = v; v.push(e); v},
    <v : (<E> S)*> <e : E?> if TrailingSep == "opt" => {
        let mut v = v;
        match e {
            None => v,
            Some e => {v.push(e); v},
        }
    }
}
// Basic terminals

Ide : String = <s:r"[a-zA-Z][a-zA-Z0-9]*"> => s.to_string();
Num : T  = <n:r"[0-9]+"> => T::from(n);

// Expression grammar

Identifier : Expression<T> = <Ide> => Expression::Identifier::<T>(<>);
Number : Expression<T> = <Num> => Expression::Number(<>);

Factor = {
    Number,
    Identifier,
    "(" <Expr> ")",
    <a:Factor>"**"<b:Number> => Expression::Pow(box a, box b)
}

Term = {
    <a:Term>"*"<b:Factor> => Expression::Mult(box a, box b),
    <a:Term>"/"<b:Factor> => Expression::Div(box a, box b),
    Factor
}

Condition : Expression<T>= {
    <a:Expr>"=="<b:Expr> => Expression::Eq(box a, box b),
    <a:Expr>"<"<b:Expr> => Expression::Lt(box a, box b),
    <a:Expr>"<="<b:Expr> => Expression::Le(box a, box b),
    <a:Expr>">"<b:Expr> => Expression::Gt(box a, box b),
    <a:Expr>">="<b:Expr> => Expression::Ge(box a, box b),
    "(" <BoolExpr> ")"
}

BoolTerm : Expression<T> = {
    <c:Condition> "&&" <b:BoolTerm> => Expression::AndAnd(box c, box b),
    <Condition>
}

BoolExpr : Expression<T> = {
    <t:BoolTerm> "||" <e:BoolExpr> => Expression::Or(box t, box e),
    <BoolTerm>
}

IfElse : Expression<T>  = "if" <a:BoolExpr> "then" <b:Expr> "else" <c:Expr> "fi"
    => Expression::IfElse(box a, box b, box c);

FunctionCall : Expression<T> = <f:Ide> "(" <args:SepList<Expr, ",", "false">> ")"
    => Expression::FunctionCall(f, args);

Expr : Expression<T> = {
    <a:Expr>"+"<b:Term> => Expression::Add(box a, box b),
    <a:Expr>"-"<b:Term> => Expression::Sub(box a, box b),
    FunctionCall,
    IfElse,
    Term
}

// Statement Grammar

Type : Type = {
    "field" => Type::FieldElement,
    "bool" => Type::Boolean
}

Definition : Vec<Statement<T>> = <x:Ide> "=" <e:Expr> => vec![Statement::Definition(x, e)];

Declaration : Vec<Statement<T>> = <t:Type> <x:Ide> "=" <e:Expr>
    => vec![Statement::Declaration(Variable::new(x.clone(), t)),
            Statement::Definition(x, e)];

ForLoop : Vec<Statement<T>> = "for" <t:Type> <i:Ide> "in" <n1:Num> ".." <n2:Num> "do"
    <s:SepList<Statement, ";", "true">>
    "endfor"
    => vec![Statement::For(Variable::new(i, t), n1, n2, s.into_iter().flatten().collect())];

Comment : Vec<Statement<T>> = r"//.*" => vec![];

Statement : Vec<Statement<T>> = {
    <Expr> "==" <Expr> => vec![Statement::Condition(<>)],
    Definition,
    Declaration,
    ForLoop,
    <Statement> Comment,
}

// Function grammar

ExpressionList : ExpressionList<T> = SepList<Expr, ",", "false"> => ExpressionList{expressions: <>};

Return : Vec<Statement<T>> = "return" <ExpressionList> => vec![Statement::Return(<>)];

FunctionArg : Parameter = <p:"private"?> <t:Type> <x:Ide>
    => Parameter{id : Variable::new(x, t), private: p.is_some()};

FunctionHeader : (String, Vec<Parameter>, Signature) = "def" <f:Ide> "(" <args:SepList<FunctionArg, ",", "false">> ")"
    "->" "(" <rets:SepList<Type, ",", "false">> ")"
    => (f, args.clone(), Signature{inputs : args.into_iter().map(|a| a.id.get_type()).collect(), outputs: rets});

Function : Function<T> = <h:FunctionHeader> <s:SepList<Statement, ";", "true">> <r:Return>
    => {let (id, args, sig) = h;
        let mut s = s;
        s.push(r);
        Function{id: id,
                 arguments: args,
                 statements: s.into_iter().flatten().collect(),
                 signature: sig}
    };

// Program grammar

As : String = "as" <Ide>;

Import : Import = "import" <p:r#""([\.\w/]*)""#> <i:As?>
    => match i {
        None => Import::new(p.to_string()),
        Some(alias) => Import::new_with_alias(p.to_string(), &alias)
    };

pub Program : Prog<T> = <imports:Import*> <functions:Function*>
    => Prog{functions, imports, imported_functions: vec![]};
