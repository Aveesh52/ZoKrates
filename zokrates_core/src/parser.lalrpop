use absy::Expression;
use field::Field;

grammar<T> where T : Field;

CommaList<E> : Vec<E> = <v:(<E> ",")*> <e:E?> => {
    match e { // (2)
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

Num: Expression<T> = <n:r"[0-9]+"> => Expression::Number::<T>(T::from(n));
Ide: Expression<T> = <s:r"[a-zA-Z][a-zA-Z0-9]*"> => Expression::Identifier::<T>(s.to_string());

Factor = {
    Num,
    Ide,
    "(" <Expr> ")",
    <a:Factor>"**"<b:Num> => Expression::Pow(box a, box b)
}

Term = {
    <a:Factor>"*"<b:Term> => Expression::Mult(box a, box b),
    <a:Factor>"/"<b:Term> => Expression::Div(box a, box b),
    Factor
}

Condition : Expression<T>= {
    <a:Expr>"=="<b:Expr> => Expression::Eq(box a, box b),
    <a:Expr>"<"<b:Expr> => Expression::Lt(box a, box b),
    <a:Expr>"<="<b:Expr> => Expression::Le(box a, box b),
    <a:Expr>">"<b:Expr> => Expression::Gt(box a, box b),
    <a:Expr>">="<b:Expr> => Expression::Ge(box a, box b),
    "(" <BoolExpr> ")"
}

BoolTerm : Expression<T> = {
    <c:Condition> "&&" <b:BoolTerm> => Expression::AndAnd(box c, box b),
    <Condition>
}

BoolExpr : Expression<T> = {
    <t:BoolTerm> "||" <e:BoolExpr> => Expression::Or(box t, box e),
    <BoolTerm>
}

IfElse: Expression<T>  = "if" <a:BoolExpr> "then" <b:Expr> "else" <c:Expr> => Expression::IfElse(box a, box b, box c);

FunctionCall : Expression<T> = <f:r"[a-zA-Z][a-zA-Z0-9]*"> "(" <args:CommaList<Expr>> ")" => Expression::FunctionCall(f.to_string(), args);

pub Expr : Expression<T> = {
    <a:Term>"+"<b:Expr> => Expression::Add(box a, box b),
    <a:Term>"-"<b:Expr> => Expression::Sub(box a, box b),
    FunctionCall,
    IfElse,
    Term
}